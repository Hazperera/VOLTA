<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>volta.simplification API documentation</title>
<meta name="description" content="Functions to simplify graph objects." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>volta.simplification</code></h1>
</header>
<section id="section-intro">
<p>Functions to simplify graph objects.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Functions to simplify graph objects.
&#34;&#34;&#34;


import pandas as pd
import glob
import sys
import os
import datetime
import math
import networkx as nx
import collections
#import matplotlib.pyplot as plt
import random
#import treelib as bt
import pickle
import itertools
from scipy.stats import kurtosis, skew, kendalltau
import statistics
import numpy
from collections import Counter
#sys.path.insert(1, &#39;../../&#39;)
#import communities
import volta.communities as communities



def add_opposit_weight(G, current_weight=&#34;weight&#34;, new_weight=&#34;distance&#34;):
    &#34;&#34;&#34;
    Function to convert distance weights into similarity weights and vice versa. Adds a new edge attribute that contains 1-x.

    Parameters:
        G (networkX graph object): to modify
        current_weight (str): edge attribute to be converted
        new_weight (str): name of to be added edge attribute.

    Returns:
        graph (networkX graph object): modified graph
    &#34;&#34;&#34;

    for edge in G.edges():
            #update current edge
            G[edge[0]][edge[1]][new_weight] = 1 - G[edge[0]][edge[1]][current_weight]


    return G

def add_absolute_weight(G, current_weight=&#34;weight&#34;, new_weight=&#34;absolute&#34;):
    &#34;&#34;&#34;
    Function to convert weights to absolute values.

    Parameters:
        G (networkX graph object): to modify
        current_weight (str): edge attribute to be converted
        new_weight (str): name of to be added edge attribute.

    Returns:
        graph (networkX graph object): modified graph
    &#34;&#34;&#34;

    for edge in G.edges():
            #update current edge
            G[edge[0]][edge[1]][new_weight] = abs(G[edge[0]][edge[1]][current_weight])


    return G


def get_min_spanning_tree(G, weight=&#34;weight&#34;, is_distance=True, new_weight=&#34;distance&#34;):
    &#34;&#34;&#34;
    Returns min spanning tree for G with minimum edge.

    Parameters:
        G (networkX graph object): needs to contains distances or similarities as weights.
        weight (str): edge attribute to be used
        is_distance (boolean): if True edge attributes are assumed to be distances. Else weights are assumend to be similarities.
        new_weight (str): if is_distance is False the estimated distances are added with this name to the graph.
                    
    Returns:
        minimum spanning tree (networkX graph object): of G 
    &#34;&#34;&#34;


    if is_distance:
        T=nx.minimum_spanning_tree(G, weight=weight)


    else:
        #estimate distance values from similarity values
        G = add_opposit_weight(G, current_weight=weight, new_weight=new_weight)
        T=nx.minimum_spanning_tree(G, weight=new_weight)


    return T


def remove_edges_per_node(G, treshold=None, percentage=None, direction=&#34;bottom&#34;, attribute=&#34;weight&#34;):
    &#34;&#34;&#34;
    Removes for each node its weakest or strongest edges, while keeping at least 1 edge per node. 
    If all are below thr treshold then none are removed.

    Parameters:
        G (networkX graph object): to modify
        treshold (float or None): in [0,1]. Edges below or above this treshold are removed. If treshold is not None percentage needs to be None.
        percentage (float or None): in [0,1]. Percentage of top/ bottom ranked edges are removed for each node individually. If percentage is not None then treshold needs to be None.
        direction (str): options are &#34;bottom&#34; (edges below treshold or weakest percentage edges are removed) and &#34;top&#34; (edges above the treshold or highest ranked perecentage edges are removed).
        attribute (str): name of edge attribute to be used.
        
    Returns:
        simplified graph (networkX graph object): of G



    &#34;&#34;&#34;
    if treshold is None and percentage is None:
        print(&#34;please set treshold or percentage &#34;)
    elif treshold is not None and percentage is not None:
        print(&#34;please set either treshold or percentage not both&#34;)

    else:

        to_remove = {}

        for node in G.nodes():
            #get nodes edges
            edges = G.edges(node)
            #print(len(edges))

            if percentage is not None:

                if (len(edges) - int(len(edges) * percentage)) &gt;= 1:
                    #remove
                    edges=sorted(G.edges(node,data=True), key=lambda t: t[2].get(attribute, 1))
                    #print(edges)
                    if direction == &#34;top&#34;:
                        
                        all_edges = len(edges)
                        remove = edges[-int(all_edges*percentage):]
                    
                    else:
                        
                        all_edges = len(edges)
                        remove = edges[:int(all_edges*percentage)+1]
                        
                        #print(remove)
                        
                    #print(&#34;possible removing &#34;, len(remove), &#34;edges for &#34;, node)
                    #G.remove_edges_from(remove)
                    for e in remove:
                        e1 = e[0]
                        e2 = e[1]

                        if (e1, e2) in to_remove.keys() or (e2, e1) in to_remove.keys():
                            if (e1, e2) in to_remove.keys():
                                c = to_remove[(e1, e2)]
                                to_remove[(e1, e2)] = c+1
                            else:
                                c = to_remove[(e2, e1)]
                                to_remove[(e2, e1)] = c+1

                        else:
                            to_remove[(e1, e2)] = 1

            

                else:
                    print(&#34;too less edges for&#34;, node)

            elif treshold is not None:
                if direction == &#34;top&#34;:
                    
                    remove = [(i,j) for i,j in G.edges(node) if G[i][j][attribute] &gt; treshold]
                else:
                    
                    remove = [(i,j) for i,j in G.edges(node) if G[i][j][attribute] &lt; treshold]

                if len(remove) == len(edges):
                    print(&#34;all edges are below treshold none are removed&#34;, node)
                else:
                    print(&#34;removing &#34;, len(remove), &#34;edges for &#34;, node)
                    G.remove_edges_from(remove)

        if percentage is not None:
            print(&#34;start removing&#34;)
            remove = []
            for e in to_remove.keys():
                if to_remove[e] &gt; 1:
                    remove.append(e)

            print(&#34;removing &#34;, len(remove))
            G.remove_edges_from(remove)
                            


    return G






def remove_edges(H, treshold=None, percentage=None, based_on=&#34;weight&#34;, direction=&#34;bottom&#34;, attribute=&#34;weight&#34;):

    &#34;&#34;&#34;
    Removes edges from a graph.

    Parameters:
        H (networkX graph object): to modify
        treshold (float or None): in [0,1]. Edges below or above this treshold are removed. If treshold is not None percentage needs to be None.
        percentage (float or None): in [0,1]. Percentage of top/ bottom ranked edges are removed. If percentage is not None then treshold needs to be None.
        based_on (str or list): if &#34;weight&#34; then treshold needs to be not None and all edges in the graph below or above this value are removed.
                If is list then items need to be edge IDs and all edges contained are removed.
                If is &#34;betweenness&#34; then either treshold or percentage can be set and top/ bottom edges are removed based on their edge betweenness scores.
        direction (str): options are &#34;bottom&#34; (edges below treshold or weakest percentage edges are removed) and &#34;top&#34; (edges above the treshold or highest ranked perecentage edges are removed).
        attribute (str): name of edge attribute to be used when based_on is &#34;weight&#34;.       

    Returns:
        simplified graph (networkX graph object): of H
        
    &#34;&#34;&#34;

    G = H.copy()

    if type(based_on) == type([]):
        print(&#34;removing all edges contained in based_on&#34;)

        print(&#34;removing &#34;, len(based_on), &#34;edges&#34;)
        G.remove_edges_from(based_on)


    elif based_on == &#34;weight&#34;:
        if treshold is not None and percentage is not None:
            print(&#34;please only set treshold or percentage not both&#34;)

        else:
            if treshold is not None:
                #remove edges that have weight larger or smaller tran defined in treshold
                if direction == &#34;top&#34;:
                    print(&#34;edges with weight larger than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [(i,j) for i,j in G.edges() if G[i][j][attribute] &gt; treshold]
                else:
                    print(&#34;edges with weight smaller than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [(i,j) for i,j in G.edges() if G[i][j][attribute] &lt; treshold]

                print(&#34;removing &#34;, len(remove), &#34;edges&#34;)
                G.remove_edges_from(remove)

            elif percentage is not None:
                edges=sorted(G.edges(data=True), key=lambda t: t[2].get(attribute, 1))
                #print(edges)
                if direction == &#34;top&#34;:
                    print(&#34;top &#34;, percentage, &#34;percent of edges are removed&#34;)
                    all_edges = len(edges)
                    remove = edges[-int(all_edges*percentage):]
                    

                    
                else:
                    print(&#34;bottom &#34;, percentage, &#34;percent of edges are removed&#34;)
                    all_edges = len(edges)
                    remove = edges[:int(all_edges*percentage)]
                    
                print(&#34;removing &#34;, len(remove), &#34;edges&#34;)
                G.remove_edges_from(remove)

            else:
                print(&#34;treshold or percentage need to be set to float, no edges will be removed&#34;)

    elif based_on == &#34;betweenness&#34;:
        betweenness = nx.edge_betweenness_centrality(G, weight=attribute)
        #print(betweenness)

        #sort after values
        s = {k: v for k, v in sorted(betweenness.items(), key=lambda item: item[1])} #small to high
        edges = list(s.keys())

        if treshold is not None and percentage is not None:
            print(&#34;please only set treshold or percentage not both&#34;)

        else:
        

            if treshold is not None:
                #remove edges that have weight larger or smaller tran defined in treshold
                if direction == &#34;top&#34;:
                    print(&#34;edges with betweenness larger than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [key for key in s.keys() if s[key] &gt; treshold]
                else:
                    print(&#34;edges with betweenness smaller than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [key for key in s.keys() if s[key] &lt; treshold]

                print(&#34;removing &#34;, len(remove), &#34;edges&#34;)
                G.remove_edges_from(remove)

            elif percentage is not None:

                if direction == &#34;top&#34;:
                    print(&#34;top &#34;, percentage, &#34;percent of edges are removed&#34;)
                    all_edges = len(edges)
                    remove = edges[-int(all_edges*percentage):]
        
                else:
                    print(&#34;bottom &#34;, percentage, &#34;percent of edges are removed&#34;)
                    all_edges = len(edges)
                    remove = edges[:int(all_edges*percentage)]
                    
                print(&#34;removing &#34;, len(remove), &#34;edges&#34;)
                G.remove_edges_from(remove)

            else:
                print(&#34;please set treshold or percentage&#34;)

    else:
        print(&#34;simiplification method not known&#34;)

    return G



def remove_nodes(H, treshold=None, percentage=None, based_on=&#34;degree&#34;, direction=&#34;bottom&#34;):

    &#34;&#34;&#34;
    Removes nodes from a graph.

        H (networkX graph object): to modify
        treshold (float or None): in [0,1]. Nodes below or above this treshold are removed. If treshold is not None percentage needs to be None.
        percentage (float or None): in [0,1]. Percentage of top/ bottom ranked nodes are removed. If percentage is not None then treshold needs to be None.
        based_on (str or list): if is &#34;degree&#34; nodes are removed based on their degree centrality. If is &#34;betweenness&#34; nodes are removed on their betweenness centrality scores.
                If is &#34;closeness&#34; nodes are removed based on their closeness centrality scores. If is list then items need to be node IDs and these nodes are removed from the graph.
        direction (str): options are &#34;bottom&#34; (nodes below treshold or weakest percentage of nodes are removed) and &#34;top&#34; (nodes above the treshold or highest ranked perecentage nodes are removed).
        
    Returns:
        simplified graph (networkX graph object): of H
    &#34;&#34;&#34;

    G = H.copy()

    if type(based_on) == type([]):
        print(&#34;removing all nodes contained in based_on&#34;)

        print(&#34;removing &#34;, len(based_on), &#34;nodes&#34;)
        G.remove_nodes_frome(based_on)

    elif based_on == &#34;degree&#34;:
        degree = nx.degree_centrality(G)
        #print(degree)
        #sort after values
        s = {k: v for k, v in sorted(degree.items(), key=lambda item: item[1])} #small to high
        nodes = list(s.keys())

        if treshold is not None and percentage is not None:
            print(&#34;please only set treshold or percentage not both&#34;)

        else:

        

            if treshold is not None:
                #remove nodes that have weight larger or smaller tran defined in treshold
                if direction == &#34;top&#34;:
                    print(&#34;nodes with degree larger than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [key for key in s.keys() if s[key] &gt; treshold]
                else:
                    print(&#34;nodes with degree smaller than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [key for key in s.keys() if s[key] &lt; treshold]

                print(&#34;removing &#34;, len(remove), &#34;nodes&#34;)
                G.remove_nodes_from(remove)

            elif percentage is not None:

                if direction == &#34;top&#34;:
                    print(&#34;top &#34;, percentage, &#34;percent of nodes are removed&#34;)
                    all_nodes = len(nodes)
                    remove = nodes[-int(all_nodes*percentage):]
        
                else:
                    print(&#34;bottom &#34;, percentage, &#34;percent of nodes are removed&#34;)
                    all_nodes = len(nodes)
                    remove = nodes[:int(all_nodes*percentage)]
                    
                print(&#34;removing &#34;, len(remove), &#34;nodes&#34;)
                G.remove_nodes_from(remove)

            else:
                print(&#34;please set treshold or percentage value&#34;)




    elif based_on == &#34;betweenness&#34;:
        betweenness = nx.betweenness_centrality(G)
        #print(betweenness)
        #sort after values
        s = {k: v for k, v in sorted(betweenness.items(), key=lambda item: item[1])} #small to high
        nodes = list(s.keys())

        if treshold is not None and percentage is not None:
            print(&#34;please only set treshold or percentage not both&#34;)

        else:

            if treshold is not None:
                #remove nodes that have weight larger or smaller tran defined in treshold
                if direction == &#34;top&#34;:
                    print(&#34;nodes with betweenness larger than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [key for key in s.keys() if s[key] &gt; treshold]
                else:
                    print(&#34;nodes with betweenness smaller than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [key for key in s.keys() if s[key] &lt; treshold]

                print(&#34;removing &#34;, len(remove), &#34;nodes&#34;)
                G.remove_nodes_from(remove)

            elif percentage is not None:

                if direction == &#34;top&#34;:
                    print(&#34;top &#34;, percentage, &#34;percent of nodes are removed&#34;)
                    all_nodes = len(nodes)
                    remove = nodes[-int(all_nodes*percentage):]
        
                else:
                    print(&#34;bottom &#34;, percentage, &#34;percent of nodes are removed&#34;)
                    all_nodes = len(nodes)
                    remove = nodes[:int(all_nodes*percentage)]
                    
                print(&#34;removing &#34;, len(remove), &#34;nodes&#34;)
                G.remove_nodes_from(remove)

            else:
                print(&#34;please set treshold or percentage value&#34;)

    elif based_on == &#34;closeness&#34;:
        closeness = nx.closeness_centrality(G)
        #print(closeness)
        #sort after values
        s = {k: v for k, v in sorted(closeness.items(), key=lambda item: item[1])} #small to high
        nodes = list(s.keys())

        if treshold is not None and percentage is not None:
            print(&#34;please only set treshold or percentage not both&#34;)

        else:

            if treshold is not None:
                #remove nodes that have weight larger or smaller tran defined in treshold
                if direction == &#34;top&#34;:
                    print(&#34;nodes with closeness larger than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [key for key in s.keys() if s[key] &gt; treshold]
                else:
                    print(&#34;nodes with closeness smaller than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [key for key in s.keys() if s[key] &lt; treshold]

                print(&#34;removing &#34;, len(remove), &#34;nodes&#34;)
                G.remove_nodes_from(remove)

            elif percentage is not None:

                if direction == &#34;top&#34;:
                    print(&#34;top &#34;, percentage, &#34;percent of nodes are removed&#34;)
                    all_nodes = len(nodes)
                    remove = nodes[-int(all_nodes*percentage):]
        
                else:
                    print(&#34;bottom &#34;, percentage, &#34;percent of nodes are removed&#34;)
                    all_nodes = len(nodes)
                    remove = nodes[:int(all_nodes*percentage)]
                    
                print(&#34;removing &#34;, len(remove), &#34;nodes&#34;)
                G.remove_nodes_from(remove)
            else:
                print(&#34;please set treshold or percentage value&#34;)

    else:
        print(&#34;simiplification method not known&#34;)

    return G



def simplify_weak_community_connections(H, weights=&#34;weight&#34;, t=0.2, by_degree=True, r=5, min_community=None, std=0.2):
    &#34;&#34;&#34;
    Simplification method that siplifies the graph based on one run of communities.weak_link_communities().
    Tries to find weak links between node groups, while ensuring that no new isolates occure.
    For each node a probabilistic selection of neighbors is run for r rounds based on their edge weights.
    Neigbors with less than t occurenses will be disconnected but only if this link is selected as a weak link in both directions.
    The algorithm will stop when max_iter is reached or no edges can be removed anymore.
    Only one iteration of  communities.weak_link_communities() is performed.
    
    Parameters:
        G (networkX graph object): to modify
        weights (str): edge attribute to be used.
        t (float): in [0,1]. Treshold on which edges are &#34;selected as weak&#34; and to be removed if they occure &lt;= in of samples neighbors.
        by_degree (boolean): if True then the number of samplings for each node is based on its degree. Each node will sample from its neighbors r*node_degree times.
            If is false then each nodes neighbors will be sampled r times.
        r (int) how often a nodes neighbors are sampled.  
        std (float): treshold of a nodes neighboring sampling distribution standardiviationf. If it is above std then edge removal will be performed.
        min_community (int or None): minimum community size allowed. If already disconnected components of size &lt; min_community exist, smaller communities can still occure. 
                If None will be ignored.
        
    Returns:
        simplified graph (networkX graph object): of G

    &#34;&#34;&#34;
   
    x, G = communities.weak_link_communities(H, weights=weights, t=t, max_iter=1, by_degree=by_degree, r=r, std=std, min_community=min_community, graph=True)

    return G</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="volta.simplification.add_absolute_weight"><code class="name flex">
<span>def <span class="ident">add_absolute_weight</span></span>(<span>G, current_weight='weight', new_weight='absolute')</span>
</code></dt>
<dd>
<div class="desc"><p>Function to convert weights to absolute values.</p>
<h2 id="parameters">Parameters</h2>
<p>G (networkX graph object): to modify
current_weight (str): edge attribute to be converted
new_weight (str): name of to be added edge attribute.</p>
<h2 id="returns">Returns</h2>
<p>graph (networkX graph object): modified graph</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_absolute_weight(G, current_weight=&#34;weight&#34;, new_weight=&#34;absolute&#34;):
    &#34;&#34;&#34;
    Function to convert weights to absolute values.

    Parameters:
        G (networkX graph object): to modify
        current_weight (str): edge attribute to be converted
        new_weight (str): name of to be added edge attribute.

    Returns:
        graph (networkX graph object): modified graph
    &#34;&#34;&#34;

    for edge in G.edges():
            #update current edge
            G[edge[0]][edge[1]][new_weight] = abs(G[edge[0]][edge[1]][current_weight])


    return G</code></pre>
</details>
</dd>
<dt id="volta.simplification.add_opposit_weight"><code class="name flex">
<span>def <span class="ident">add_opposit_weight</span></span>(<span>G, current_weight='weight', new_weight='distance')</span>
</code></dt>
<dd>
<div class="desc"><p>Function to convert distance weights into similarity weights and vice versa. Adds a new edge attribute that contains 1-x.</p>
<h2 id="parameters">Parameters</h2>
<p>G (networkX graph object): to modify
current_weight (str): edge attribute to be converted
new_weight (str): name of to be added edge attribute.</p>
<h2 id="returns">Returns</h2>
<p>graph (networkX graph object): modified graph</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_opposit_weight(G, current_weight=&#34;weight&#34;, new_weight=&#34;distance&#34;):
    &#34;&#34;&#34;
    Function to convert distance weights into similarity weights and vice versa. Adds a new edge attribute that contains 1-x.

    Parameters:
        G (networkX graph object): to modify
        current_weight (str): edge attribute to be converted
        new_weight (str): name of to be added edge attribute.

    Returns:
        graph (networkX graph object): modified graph
    &#34;&#34;&#34;

    for edge in G.edges():
            #update current edge
            G[edge[0]][edge[1]][new_weight] = 1 - G[edge[0]][edge[1]][current_weight]


    return G</code></pre>
</details>
</dd>
<dt id="volta.simplification.get_min_spanning_tree"><code class="name flex">
<span>def <span class="ident">get_min_spanning_tree</span></span>(<span>G, weight='weight', is_distance=True, new_weight='distance')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns min spanning tree for G with minimum edge.</p>
<h2 id="parameters">Parameters</h2>
<p>G (networkX graph object): needs to contains distances or similarities as weights.
weight (str): edge attribute to be used
is_distance (boolean): if True edge attributes are assumed to be distances. Else weights are assumend to be similarities.
new_weight (str): if is_distance is False the estimated distances are added with this name to the graph.</p>
<h2 id="returns">Returns</h2>
<p>minimum spanning tree (networkX graph object): of G</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_min_spanning_tree(G, weight=&#34;weight&#34;, is_distance=True, new_weight=&#34;distance&#34;):
    &#34;&#34;&#34;
    Returns min spanning tree for G with minimum edge.

    Parameters:
        G (networkX graph object): needs to contains distances or similarities as weights.
        weight (str): edge attribute to be used
        is_distance (boolean): if True edge attributes are assumed to be distances. Else weights are assumend to be similarities.
        new_weight (str): if is_distance is False the estimated distances are added with this name to the graph.
                    
    Returns:
        minimum spanning tree (networkX graph object): of G 
    &#34;&#34;&#34;


    if is_distance:
        T=nx.minimum_spanning_tree(G, weight=weight)


    else:
        #estimate distance values from similarity values
        G = add_opposit_weight(G, current_weight=weight, new_weight=new_weight)
        T=nx.minimum_spanning_tree(G, weight=new_weight)


    return T</code></pre>
</details>
</dd>
<dt id="volta.simplification.remove_edges"><code class="name flex">
<span>def <span class="ident">remove_edges</span></span>(<span>H, treshold=None, percentage=None, based_on='weight', direction='bottom', attribute='weight')</span>
</code></dt>
<dd>
<div class="desc"><p>Removes edges from a graph.</p>
<h2 id="parameters">Parameters</h2>
<p>H (networkX graph object): to modify
treshold (float or None): in [0,1]. Edges below or above this treshold are removed. If treshold is not None percentage needs to be None.
percentage (float or None): in [0,1]. Percentage of top/ bottom ranked edges are removed. If percentage is not None then treshold needs to be None.
based_on (str or list): if "weight" then treshold needs to be not None and all edges in the graph below or above this value are removed.
If is list then items need to be edge IDs and all edges contained are removed.
If is "betweenness" then either treshold or percentage can be set and top/ bottom edges are removed based on their edge betweenness scores.
direction (str): options are "bottom" (edges below treshold or weakest percentage edges are removed) and "top" (edges above the treshold or highest ranked perecentage edges are removed).
attribute (str): name of edge attribute to be used when based_on is "weight".
</p>
<h2 id="returns">Returns</h2>
<p>simplified graph (networkX graph object): of H</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_edges(H, treshold=None, percentage=None, based_on=&#34;weight&#34;, direction=&#34;bottom&#34;, attribute=&#34;weight&#34;):

    &#34;&#34;&#34;
    Removes edges from a graph.

    Parameters:
        H (networkX graph object): to modify
        treshold (float or None): in [0,1]. Edges below or above this treshold are removed. If treshold is not None percentage needs to be None.
        percentage (float or None): in [0,1]. Percentage of top/ bottom ranked edges are removed. If percentage is not None then treshold needs to be None.
        based_on (str or list): if &#34;weight&#34; then treshold needs to be not None and all edges in the graph below or above this value are removed.
                If is list then items need to be edge IDs and all edges contained are removed.
                If is &#34;betweenness&#34; then either treshold or percentage can be set and top/ bottom edges are removed based on their edge betweenness scores.
        direction (str): options are &#34;bottom&#34; (edges below treshold or weakest percentage edges are removed) and &#34;top&#34; (edges above the treshold or highest ranked perecentage edges are removed).
        attribute (str): name of edge attribute to be used when based_on is &#34;weight&#34;.       

    Returns:
        simplified graph (networkX graph object): of H
        
    &#34;&#34;&#34;

    G = H.copy()

    if type(based_on) == type([]):
        print(&#34;removing all edges contained in based_on&#34;)

        print(&#34;removing &#34;, len(based_on), &#34;edges&#34;)
        G.remove_edges_from(based_on)


    elif based_on == &#34;weight&#34;:
        if treshold is not None and percentage is not None:
            print(&#34;please only set treshold or percentage not both&#34;)

        else:
            if treshold is not None:
                #remove edges that have weight larger or smaller tran defined in treshold
                if direction == &#34;top&#34;:
                    print(&#34;edges with weight larger than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [(i,j) for i,j in G.edges() if G[i][j][attribute] &gt; treshold]
                else:
                    print(&#34;edges with weight smaller than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [(i,j) for i,j in G.edges() if G[i][j][attribute] &lt; treshold]

                print(&#34;removing &#34;, len(remove), &#34;edges&#34;)
                G.remove_edges_from(remove)

            elif percentage is not None:
                edges=sorted(G.edges(data=True), key=lambda t: t[2].get(attribute, 1))
                #print(edges)
                if direction == &#34;top&#34;:
                    print(&#34;top &#34;, percentage, &#34;percent of edges are removed&#34;)
                    all_edges = len(edges)
                    remove = edges[-int(all_edges*percentage):]
                    

                    
                else:
                    print(&#34;bottom &#34;, percentage, &#34;percent of edges are removed&#34;)
                    all_edges = len(edges)
                    remove = edges[:int(all_edges*percentage)]
                    
                print(&#34;removing &#34;, len(remove), &#34;edges&#34;)
                G.remove_edges_from(remove)

            else:
                print(&#34;treshold or percentage need to be set to float, no edges will be removed&#34;)

    elif based_on == &#34;betweenness&#34;:
        betweenness = nx.edge_betweenness_centrality(G, weight=attribute)
        #print(betweenness)

        #sort after values
        s = {k: v for k, v in sorted(betweenness.items(), key=lambda item: item[1])} #small to high
        edges = list(s.keys())

        if treshold is not None and percentage is not None:
            print(&#34;please only set treshold or percentage not both&#34;)

        else:
        

            if treshold is not None:
                #remove edges that have weight larger or smaller tran defined in treshold
                if direction == &#34;top&#34;:
                    print(&#34;edges with betweenness larger than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [key for key in s.keys() if s[key] &gt; treshold]
                else:
                    print(&#34;edges with betweenness smaller than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [key for key in s.keys() if s[key] &lt; treshold]

                print(&#34;removing &#34;, len(remove), &#34;edges&#34;)
                G.remove_edges_from(remove)

            elif percentage is not None:

                if direction == &#34;top&#34;:
                    print(&#34;top &#34;, percentage, &#34;percent of edges are removed&#34;)
                    all_edges = len(edges)
                    remove = edges[-int(all_edges*percentage):]
        
                else:
                    print(&#34;bottom &#34;, percentage, &#34;percent of edges are removed&#34;)
                    all_edges = len(edges)
                    remove = edges[:int(all_edges*percentage)]
                    
                print(&#34;removing &#34;, len(remove), &#34;edges&#34;)
                G.remove_edges_from(remove)

            else:
                print(&#34;please set treshold or percentage&#34;)

    else:
        print(&#34;simiplification method not known&#34;)

    return G</code></pre>
</details>
</dd>
<dt id="volta.simplification.remove_edges_per_node"><code class="name flex">
<span>def <span class="ident">remove_edges_per_node</span></span>(<span>G, treshold=None, percentage=None, direction='bottom', attribute='weight')</span>
</code></dt>
<dd>
<div class="desc"><p>Removes for each node its weakest or strongest edges, while keeping at least 1 edge per node.
If all are below thr treshold then none are removed.</p>
<h2 id="parameters">Parameters</h2>
<p>G (networkX graph object): to modify
treshold (float or None): in [0,1]. Edges below or above this treshold are removed. If treshold is not None percentage needs to be None.
percentage (float or None): in [0,1]. Percentage of top/ bottom ranked edges are removed for each node individually. If percentage is not None then treshold needs to be None.
direction (str): options are "bottom" (edges below treshold or weakest percentage edges are removed) and "top" (edges above the treshold or highest ranked perecentage edges are removed).
attribute (str): name of edge attribute to be used.</p>
<h2 id="returns">Returns</h2>
<p>simplified graph (networkX graph object): of G</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_edges_per_node(G, treshold=None, percentage=None, direction=&#34;bottom&#34;, attribute=&#34;weight&#34;):
    &#34;&#34;&#34;
    Removes for each node its weakest or strongest edges, while keeping at least 1 edge per node. 
    If all are below thr treshold then none are removed.

    Parameters:
        G (networkX graph object): to modify
        treshold (float or None): in [0,1]. Edges below or above this treshold are removed. If treshold is not None percentage needs to be None.
        percentage (float or None): in [0,1]. Percentage of top/ bottom ranked edges are removed for each node individually. If percentage is not None then treshold needs to be None.
        direction (str): options are &#34;bottom&#34; (edges below treshold or weakest percentage edges are removed) and &#34;top&#34; (edges above the treshold or highest ranked perecentage edges are removed).
        attribute (str): name of edge attribute to be used.
        
    Returns:
        simplified graph (networkX graph object): of G



    &#34;&#34;&#34;
    if treshold is None and percentage is None:
        print(&#34;please set treshold or percentage &#34;)
    elif treshold is not None and percentage is not None:
        print(&#34;please set either treshold or percentage not both&#34;)

    else:

        to_remove = {}

        for node in G.nodes():
            #get nodes edges
            edges = G.edges(node)
            #print(len(edges))

            if percentage is not None:

                if (len(edges) - int(len(edges) * percentage)) &gt;= 1:
                    #remove
                    edges=sorted(G.edges(node,data=True), key=lambda t: t[2].get(attribute, 1))
                    #print(edges)
                    if direction == &#34;top&#34;:
                        
                        all_edges = len(edges)
                        remove = edges[-int(all_edges*percentage):]
                    
                    else:
                        
                        all_edges = len(edges)
                        remove = edges[:int(all_edges*percentage)+1]
                        
                        #print(remove)
                        
                    #print(&#34;possible removing &#34;, len(remove), &#34;edges for &#34;, node)
                    #G.remove_edges_from(remove)
                    for e in remove:
                        e1 = e[0]
                        e2 = e[1]

                        if (e1, e2) in to_remove.keys() or (e2, e1) in to_remove.keys():
                            if (e1, e2) in to_remove.keys():
                                c = to_remove[(e1, e2)]
                                to_remove[(e1, e2)] = c+1
                            else:
                                c = to_remove[(e2, e1)]
                                to_remove[(e2, e1)] = c+1

                        else:
                            to_remove[(e1, e2)] = 1

            

                else:
                    print(&#34;too less edges for&#34;, node)

            elif treshold is not None:
                if direction == &#34;top&#34;:
                    
                    remove = [(i,j) for i,j in G.edges(node) if G[i][j][attribute] &gt; treshold]
                else:
                    
                    remove = [(i,j) for i,j in G.edges(node) if G[i][j][attribute] &lt; treshold]

                if len(remove) == len(edges):
                    print(&#34;all edges are below treshold none are removed&#34;, node)
                else:
                    print(&#34;removing &#34;, len(remove), &#34;edges for &#34;, node)
                    G.remove_edges_from(remove)

        if percentage is not None:
            print(&#34;start removing&#34;)
            remove = []
            for e in to_remove.keys():
                if to_remove[e] &gt; 1:
                    remove.append(e)

            print(&#34;removing &#34;, len(remove))
            G.remove_edges_from(remove)
                            


    return G</code></pre>
</details>
</dd>
<dt id="volta.simplification.remove_nodes"><code class="name flex">
<span>def <span class="ident">remove_nodes</span></span>(<span>H, treshold=None, percentage=None, based_on='degree', direction='bottom')</span>
</code></dt>
<dd>
<div class="desc"><p>Removes nodes from a graph.</p>
<pre><code>H (networkX graph object): to modify
treshold (float or None): in [0,1]. Nodes below or above this treshold are removed. If treshold is not None percentage needs to be None.
percentage (float or None): in [0,1]. Percentage of top/ bottom ranked nodes are removed. If percentage is not None then treshold needs to be None.
based_on (str or list): if is "degree" nodes are removed based on their degree centrality. If is "betweenness" nodes are removed on their betweenness centrality scores.
        If is "closeness" nodes are removed based on their closeness centrality scores. If is list then items need to be node IDs and these nodes are removed from the graph.
direction (str): options are "bottom" (nodes below treshold or weakest percentage of nodes are removed) and "top" (nodes above the treshold or highest ranked perecentage nodes are removed).
</code></pre>
<h2 id="returns">Returns</h2>
<p>simplified graph (networkX graph object): of H</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_nodes(H, treshold=None, percentage=None, based_on=&#34;degree&#34;, direction=&#34;bottom&#34;):

    &#34;&#34;&#34;
    Removes nodes from a graph.

        H (networkX graph object): to modify
        treshold (float or None): in [0,1]. Nodes below or above this treshold are removed. If treshold is not None percentage needs to be None.
        percentage (float or None): in [0,1]. Percentage of top/ bottom ranked nodes are removed. If percentage is not None then treshold needs to be None.
        based_on (str or list): if is &#34;degree&#34; nodes are removed based on their degree centrality. If is &#34;betweenness&#34; nodes are removed on their betweenness centrality scores.
                If is &#34;closeness&#34; nodes are removed based on their closeness centrality scores. If is list then items need to be node IDs and these nodes are removed from the graph.
        direction (str): options are &#34;bottom&#34; (nodes below treshold or weakest percentage of nodes are removed) and &#34;top&#34; (nodes above the treshold or highest ranked perecentage nodes are removed).
        
    Returns:
        simplified graph (networkX graph object): of H
    &#34;&#34;&#34;

    G = H.copy()

    if type(based_on) == type([]):
        print(&#34;removing all nodes contained in based_on&#34;)

        print(&#34;removing &#34;, len(based_on), &#34;nodes&#34;)
        G.remove_nodes_frome(based_on)

    elif based_on == &#34;degree&#34;:
        degree = nx.degree_centrality(G)
        #print(degree)
        #sort after values
        s = {k: v for k, v in sorted(degree.items(), key=lambda item: item[1])} #small to high
        nodes = list(s.keys())

        if treshold is not None and percentage is not None:
            print(&#34;please only set treshold or percentage not both&#34;)

        else:

        

            if treshold is not None:
                #remove nodes that have weight larger or smaller tran defined in treshold
                if direction == &#34;top&#34;:
                    print(&#34;nodes with degree larger than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [key for key in s.keys() if s[key] &gt; treshold]
                else:
                    print(&#34;nodes with degree smaller than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [key for key in s.keys() if s[key] &lt; treshold]

                print(&#34;removing &#34;, len(remove), &#34;nodes&#34;)
                G.remove_nodes_from(remove)

            elif percentage is not None:

                if direction == &#34;top&#34;:
                    print(&#34;top &#34;, percentage, &#34;percent of nodes are removed&#34;)
                    all_nodes = len(nodes)
                    remove = nodes[-int(all_nodes*percentage):]
        
                else:
                    print(&#34;bottom &#34;, percentage, &#34;percent of nodes are removed&#34;)
                    all_nodes = len(nodes)
                    remove = nodes[:int(all_nodes*percentage)]
                    
                print(&#34;removing &#34;, len(remove), &#34;nodes&#34;)
                G.remove_nodes_from(remove)

            else:
                print(&#34;please set treshold or percentage value&#34;)




    elif based_on == &#34;betweenness&#34;:
        betweenness = nx.betweenness_centrality(G)
        #print(betweenness)
        #sort after values
        s = {k: v for k, v in sorted(betweenness.items(), key=lambda item: item[1])} #small to high
        nodes = list(s.keys())

        if treshold is not None and percentage is not None:
            print(&#34;please only set treshold or percentage not both&#34;)

        else:

            if treshold is not None:
                #remove nodes that have weight larger or smaller tran defined in treshold
                if direction == &#34;top&#34;:
                    print(&#34;nodes with betweenness larger than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [key for key in s.keys() if s[key] &gt; treshold]
                else:
                    print(&#34;nodes with betweenness smaller than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [key for key in s.keys() if s[key] &lt; treshold]

                print(&#34;removing &#34;, len(remove), &#34;nodes&#34;)
                G.remove_nodes_from(remove)

            elif percentage is not None:

                if direction == &#34;top&#34;:
                    print(&#34;top &#34;, percentage, &#34;percent of nodes are removed&#34;)
                    all_nodes = len(nodes)
                    remove = nodes[-int(all_nodes*percentage):]
        
                else:
                    print(&#34;bottom &#34;, percentage, &#34;percent of nodes are removed&#34;)
                    all_nodes = len(nodes)
                    remove = nodes[:int(all_nodes*percentage)]
                    
                print(&#34;removing &#34;, len(remove), &#34;nodes&#34;)
                G.remove_nodes_from(remove)

            else:
                print(&#34;please set treshold or percentage value&#34;)

    elif based_on == &#34;closeness&#34;:
        closeness = nx.closeness_centrality(G)
        #print(closeness)
        #sort after values
        s = {k: v for k, v in sorted(closeness.items(), key=lambda item: item[1])} #small to high
        nodes = list(s.keys())

        if treshold is not None and percentage is not None:
            print(&#34;please only set treshold or percentage not both&#34;)

        else:

            if treshold is not None:
                #remove nodes that have weight larger or smaller tran defined in treshold
                if direction == &#34;top&#34;:
                    print(&#34;nodes with closeness larger than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [key for key in s.keys() if s[key] &gt; treshold]
                else:
                    print(&#34;nodes with closeness smaller than &#34;, treshold, &#34;will be removed&#34;)
                    remove = [key for key in s.keys() if s[key] &lt; treshold]

                print(&#34;removing &#34;, len(remove), &#34;nodes&#34;)
                G.remove_nodes_from(remove)

            elif percentage is not None:

                if direction == &#34;top&#34;:
                    print(&#34;top &#34;, percentage, &#34;percent of nodes are removed&#34;)
                    all_nodes = len(nodes)
                    remove = nodes[-int(all_nodes*percentage):]
        
                else:
                    print(&#34;bottom &#34;, percentage, &#34;percent of nodes are removed&#34;)
                    all_nodes = len(nodes)
                    remove = nodes[:int(all_nodes*percentage)]
                    
                print(&#34;removing &#34;, len(remove), &#34;nodes&#34;)
                G.remove_nodes_from(remove)
            else:
                print(&#34;please set treshold or percentage value&#34;)

    else:
        print(&#34;simiplification method not known&#34;)

    return G</code></pre>
</details>
</dd>
<dt id="volta.simplification.simplify_weak_community_connections"><code class="name flex">
<span>def <span class="ident">simplify_weak_community_connections</span></span>(<span>H, weights='weight', t=0.2, by_degree=True, r=5, min_community=None, std=0.2)</span>
</code></dt>
<dd>
<div class="desc"><p>Simplification method that siplifies the graph based on one run of communities.weak_link_communities().
Tries to find weak links between node groups, while ensuring that no new isolates occure.
For each node a probabilistic selection of neighbors is run for r rounds based on their edge weights.
Neigbors with less than t occurenses will be disconnected but only if this link is selected as a weak link in both directions.
The algorithm will stop when max_iter is reached or no edges can be removed anymore.
Only one iteration of
communities.weak_link_communities() is performed.</p>
<h2 id="parameters">Parameters</h2>
<p>G (networkX graph object): to modify
weights (str): edge attribute to be used.
t (float): in [0,1]. Treshold on which edges are "selected as weak" and to be removed if they occure &lt;= in of samples neighbors.
by_degree (boolean): if True then the number of samplings for each node is based on its degree. Each node will sample from its neighbors r*node_degree times.
If is false then each nodes neighbors will be sampled r times.
r (int) how often a nodes neighbors are sampled.<br>
std (float): treshold of a nodes neighboring sampling distribution standardiviationf. If it is above std then edge removal will be performed.
min_community (int or None): minimum community size allowed. If already disconnected components of size &lt; min_community exist, smaller communities can still occure.
If None will be ignored.</p>
<h2 id="returns">Returns</h2>
<p>simplified graph (networkX graph object): of G</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplify_weak_community_connections(H, weights=&#34;weight&#34;, t=0.2, by_degree=True, r=5, min_community=None, std=0.2):
    &#34;&#34;&#34;
    Simplification method that siplifies the graph based on one run of communities.weak_link_communities().
    Tries to find weak links between node groups, while ensuring that no new isolates occure.
    For each node a probabilistic selection of neighbors is run for r rounds based on their edge weights.
    Neigbors with less than t occurenses will be disconnected but only if this link is selected as a weak link in both directions.
    The algorithm will stop when max_iter is reached or no edges can be removed anymore.
    Only one iteration of  communities.weak_link_communities() is performed.
    
    Parameters:
        G (networkX graph object): to modify
        weights (str): edge attribute to be used.
        t (float): in [0,1]. Treshold on which edges are &#34;selected as weak&#34; and to be removed if they occure &lt;= in of samples neighbors.
        by_degree (boolean): if True then the number of samplings for each node is based on its degree. Each node will sample from its neighbors r*node_degree times.
            If is false then each nodes neighbors will be sampled r times.
        r (int) how often a nodes neighbors are sampled.  
        std (float): treshold of a nodes neighboring sampling distribution standardiviationf. If it is above std then edge removal will be performed.
        min_community (int or None): minimum community size allowed. If already disconnected components of size &lt; min_community exist, smaller communities can still occure. 
                If None will be ignored.
        
    Returns:
        simplified graph (networkX graph object): of G

    &#34;&#34;&#34;
   
    x, G = communities.weak_link_communities(H, weights=weights, t=t, max_iter=1, by_degree=by_degree, r=r, std=std, min_community=min_community, graph=True)

    return G</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="volta" href="index.html">volta</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="volta.simplification.add_absolute_weight" href="#volta.simplification.add_absolute_weight">add_absolute_weight</a></code></li>
<li><code><a title="volta.simplification.add_opposit_weight" href="#volta.simplification.add_opposit_weight">add_opposit_weight</a></code></li>
<li><code><a title="volta.simplification.get_min_spanning_tree" href="#volta.simplification.get_min_spanning_tree">get_min_spanning_tree</a></code></li>
<li><code><a title="volta.simplification.remove_edges" href="#volta.simplification.remove_edges">remove_edges</a></code></li>
<li><code><a title="volta.simplification.remove_edges_per_node" href="#volta.simplification.remove_edges_per_node">remove_edges_per_node</a></code></li>
<li><code><a title="volta.simplification.remove_nodes" href="#volta.simplification.remove_nodes">remove_nodes</a></code></li>
<li><code><a title="volta.simplification.simplify_weak_community_connections" href="#volta.simplification.simplify_weak_community_connections">simplify_weak_community_connections</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>