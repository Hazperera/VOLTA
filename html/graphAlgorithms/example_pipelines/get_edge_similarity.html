<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>graphAlgorithms.example_pipelines.get_edge_similarity API documentation</title>
<meta name="description" content="This is an example pipeline on how to estimate the similarity between multiple networks
based on their similarity in shared
edges" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>graphAlgorithms.example_pipelines.get_edge_similarity</code></h1>
</header>
<section id="section-intro">
<p>This is an example pipeline on how to estimate the similarity between multiple networks
based on their similarity in shared
edges</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This is an example pipeline on how to estimate the similarity between multiple networks
based on their similarity in shared  edges
&#34;&#34;&#34;

import networkx as nx
import pandas as pd
import csv
import random
import sys
import graphAlgorithms.distances.global_distances as global_distances
import graphAlgorithms.distances.local as local
import graphAlgorithms.simplification as simplification
import graphAlgorithms.distances.trees as trees
import graphAlgorithms.distances.node_edge_similarities as node_edge_similarities
import pickle
from scipy.stats import kurtosis, skew, kendalltau
import statistics
import numpy as np
import scipy

def preprocess_graph(net_temp, attribute=&#34;weight&#34;, location = None, labels = None):
    &#34;&#34;&#34;
    function to convert list of networkx graph objects into list of sublist format as needed by
    these functions

    Input
        net_temp list of networkx graph objects

        weight edge attribute to be converted

        location is str of were output should be saved
            if None then a list of edgelists is returned else their pickled location is returned

        labels is list of network names in same order as in net_temp
            only needed if location is not None

    Output
        list of graph objects in edge list format or if location is not None list of path location of saved objects
    &#34;&#34;&#34;
    
    if location is None:
        networks = []
        for n in net_temp:
            temp = []
            edges = list(n.edges())
            for edge in edges:
                temp.append([edge[0], edge[1], n[edge[0]][edge[1]][attribute]])

            networks.append(temp)

        return networks

    else:
        networks = []
        for i in range(len(net_temp)):
            path = net_temp[i]
            name = labels[i]
            n=nx.read_weighted_edgelist(path)

            temp = []
            edges = list(n.edges())
            for edge in edges:
                temp.append([edge[0], edge[1], n[edge[0]][edge[1]][attribute]])

                        
            #save converted
            print(&#34;save&#34;, name)
            with open(location + name+&#34;.pckl&#34;, &#34;wb&#34;) as f:
                pickle.dump(temp, f, protocol=4)

            networks.append(location + name+&#34;.pckl&#34;)

        return networks

def preprocess_edge_list(networks, is_file = False, location = None, names= None):
    &#34;&#34;&#34;
    function to map edges to ids for faster &amp; easier computation

    Input
        output of preprocess_graph
        is_file if False then networks is list of networkx objects
            if True then networks is list of file locations to python pickles
                if True converted networks are saved as pickles to location
        location str to where converted networks should be saved - will only be used if is_file is True

        names list of network names in same order as networks

    Output
        list of converted networks (or str to saved location)

        dict of edge to id mapping which can be used to reverse mapping
            in order to withdraw later information mapping needs to be kept
            key is str of node ids in format &#34;node1, node2&#34;, which can be split into a list
                both edge directions are stored &amp; the same value is assigned to them
            value is id assigned to the particular edge

    &#34;&#34;&#34;

    if not is_file:
        for i in range(len(networks)):
            if i == 0:
                m, n = node_edge_similarities.map_edge_to_id(networks[i], mapping={}, next_value=0)

            else:
                m, n = node_edge_similarities.map_edge_to_id(networks[i], mapping=m, next_value=n)

        network_lists = []
        for net in networks:
            network_lists.append(node_edge_similarities.construct_mapped_edge(m, net))

        return network_lists, m


    else:
        for i in range(len(networks)):
            #load file from disk
            
            with open(networks[i], &#34;rb&#34;) as f:
                net = pickle.load(f)

            if i % 10 == 0:
                print(&#34;loaded &#34;, i , &#34;network from disk out of &#34;, len(networks))


            if i == 0:
                m, n = node_edge_similarities.map_edge_to_id(net, mapping={}, next_value=0)

            else:
                m, n = node_edge_similarities.map_edge_to_id(net, mapping=m, next_value=n)


        network_lists = []
        for i in range(len(networks)):
            with open(networks[i], &#34;rb&#34;) as f:
                net = pickle.load(f)

            lst = list(dict.fromkeys(node_edge_similarities.construct_mapped_edge(m, net)))
            #save
            name = names[i]

            with open(location + name+&#34;.pckl&#34;, &#34;wb&#34;) as f:
                pickle.dump(lst, f, protocol=4)

            print(&#34;saved&#34;)
            network_lists.append(location + name+&#34;.pckl&#34;)

        return network_lists, m

def sort_list_and_get_shared(networks, m, network_lists, labels, is_file = False):
    &#34;&#34;&#34;
    preprocessing function to sort edge list after weight

    Input
        output of preprocess_graph
        mapping as returned by preprocess_edge_list
        network_list as returned by preprocess_edge_list
        labels is list of str containing names of each layer for later identification
        if is_file is True then networks is list of paths to pickled networks else contains python objects

    Output
        list of networks containing sorted edge list
        dict of shared edges between networks
            key is edge id as provided in m &amp; value is list of labels in which this edge occures
        binary representation of networks edges based on all possible edges in all networks
    &#34;&#34;&#34;

    sorted_networks = []
    if not is_file:
        for net in networks:
            sorted_networks.append(node_edge_similarities.sort_edge_list(net, m))

    else:
        for path in networks:
            with open(path, &#34;rb&#34;) as f:
                net = pickle.load(f)

            sorted_networks.append(node_edge_similarities.sort_edge_list(net, m))

    shared_edges = node_edge_similarities.compute_shared_layers(network_lists, labels, mapping = None, weight=False)

    binary = node_edge_similarities.compute_binary_layer(shared_edges, layers=labels)

    return sorted_networks, shared_edges, binary

def sort_list(networks, m,  is_file = False, location=None):
    &#34;&#34;&#34;
    preprocessing function to sort edge list after weight

    Input
        output of preprocess_graph
        mapping as returned by preprocess_edge_list
        
        if is_file is True then networks is list of paths to pickled networks else contains python objects

    Output
        list of networks containing sorted edge list or if_file then contains file location of pickled objects
        
    &#34;&#34;&#34;

    sorted_networks = []
    if not is_file:
        for net in networks:
            sorted_networks.append(node_edge_similarities.sort_edge_list(net, m))

    else:
        for path in networks:
            with open(path, &#34;rb&#34;) as f:
                net = pickle.load(f)
            name =  path.split(&#34;/&#34;)[-1].replace(&#34;.pckl&#34;, &#34;&#34;)
            temp = node_edge_similarities.sort_edge_list(net, m)

            with open(location + name+&#34;.pckl&#34;, &#34;wb&#34;) as f:
                pickle.dump(temp, f, protocol=4)

            sorted_networks.append(location + name+&#34;.pckl&#34;)

    

    return sorted_networks


def get_shared(network_lists, labels, is_file = False):
    &#34;&#34;&#34;
    preprocessing function to sort edge list after weight

    Input
        
        
        network_list as returned by preprocess_edge_list
        labels is list of str containing names of each layer for later identification
        if is_file is True then network_lists is list of paths to pickled networks else contains python objects

    Output
        list of networks containing sorted edge list
        dict of shared edges between networks
            key is edge id as provided in m &amp; value is list of labels in which this edge occures
        binary representation of networks edges based on all possible edges in all networks
    &#34;&#34;&#34;

    

    shared_edges = node_edge_similarities.compute_shared_layers(network_lists, labels, mapping = None, weight=False, is_file=is_file)

    binary = node_edge_similarities.compute_binary_layer(shared_edges, layers=labels)

    return shared_edges, binary


def estimate_similarities_edges(network_lists, sorted_networks, binary,  kendall_x=50, is_file=True):
    &#34;&#34;&#34;
    function to estimate edge similarities

    Input
        network_lists as returned by preprocess_edge_list()

        sorted_networks as returned by sort_list_and_get_shared

        binary as returned by sort_list_and_get_shared

        kendall_x number of edges to be considered in kendall ranking (top)

        if is_file then network_lists is list of file location of pickled network objects

    Output
        numpy matrices containing

        jaccard similarity, jaccard distance, similarity
        kendall correlation, hamming distance
    &#34;&#34;&#34;

    j, percentage = node_edge_similarities.shared_elements_multiple(network_lists,  labels=None, percentage=True, jaccard=True, jaccard_similarity = True, penalize_percentage=False, is_file=is_file)
    jd = node_edge_similarities.to_distance(j)

    kendall_top ,b_top, x = node_edge_similarities.build_similarity_matrix_for_binary_and_ranked(sorted_networks, compute=&#34;kendall&#34;, kendall_usage=&#34;top&#34;, kendall_x = kendall_x)

    kendall_bottom ,b_bottom, x = node_edge_similarities.build_similarity_matrix_for_binary_and_ranked(sorted_networks, compute=&#34;kendall&#34;, kendall_usage=&#34;bottom&#34;, kendall_x = kendall_x)

    hamming, p = node_edge_similarities.build_similarity_matrix_for_binary_and_ranked(binary, compute=&#34;hamming&#34;)

    smc, p = node_edge_similarities.build_similarity_matrix_for_binary_and_ranked(binary, compute=&#34;smc&#34;)


    return j, jd, percentage, kendall_top,b_top, kendall_bottom, b_bottom, hamming, smc</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="graphAlgorithms.example_pipelines.get_edge_similarity.estimate_similarities_edges"><code class="name flex">
<span>def <span class="ident">estimate_similarities_edges</span></span>(<span>network_lists, sorted_networks, binary, kendall_x=50, is_file=True)</span>
</code></dt>
<dd>
<section class="desc"><p>function to estimate edge similarities</p>
<p>Input
network_lists as returned by preprocess_edge_list()</p>
<pre><code>sorted_networks as returned by sort_list_and_get_shared

binary as returned by sort_list_and_get_shared

kendall_x number of edges to be considered in kendall ranking (top)

if is_file then network_lists is list of file location of pickled network objects
</code></pre>
<p>Output
numpy matrices containing</p>
<pre><code>jaccard similarity, jaccard distance, similarity
kendall correlation, hamming distance
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_similarities_edges(network_lists, sorted_networks, binary,  kendall_x=50, is_file=True):
    &#34;&#34;&#34;
    function to estimate edge similarities

    Input
        network_lists as returned by preprocess_edge_list()

        sorted_networks as returned by sort_list_and_get_shared

        binary as returned by sort_list_and_get_shared

        kendall_x number of edges to be considered in kendall ranking (top)

        if is_file then network_lists is list of file location of pickled network objects

    Output
        numpy matrices containing

        jaccard similarity, jaccard distance, similarity
        kendall correlation, hamming distance
    &#34;&#34;&#34;

    j, percentage = node_edge_similarities.shared_elements_multiple(network_lists,  labels=None, percentage=True, jaccard=True, jaccard_similarity = True, penalize_percentage=False, is_file=is_file)
    jd = node_edge_similarities.to_distance(j)

    kendall_top ,b_top, x = node_edge_similarities.build_similarity_matrix_for_binary_and_ranked(sorted_networks, compute=&#34;kendall&#34;, kendall_usage=&#34;top&#34;, kendall_x = kendall_x)

    kendall_bottom ,b_bottom, x = node_edge_similarities.build_similarity_matrix_for_binary_and_ranked(sorted_networks, compute=&#34;kendall&#34;, kendall_usage=&#34;bottom&#34;, kendall_x = kendall_x)

    hamming, p = node_edge_similarities.build_similarity_matrix_for_binary_and_ranked(binary, compute=&#34;hamming&#34;)

    smc, p = node_edge_similarities.build_similarity_matrix_for_binary_and_ranked(binary, compute=&#34;smc&#34;)


    return j, jd, percentage, kendall_top,b_top, kendall_bottom, b_bottom, hamming, smc</code></pre>
</details>
</dd>
<dt id="graphAlgorithms.example_pipelines.get_edge_similarity.get_shared"><code class="name flex">
<span>def <span class="ident">get_shared</span></span>(<span>network_lists, labels, is_file=False)</span>
</code></dt>
<dd>
<section class="desc"><p>preprocessing function to sort edge list after weight</p>
<p>Input</p>
<pre><code>network_list as returned by preprocess_edge_list
labels is list of str containing names of each layer for later identification
if is_file is True then network_lists is list of paths to pickled networks else contains python objects
</code></pre>
<p>Output
list of networks containing sorted edge list
dict of shared edges between networks
key is edge id as provided in m &amp; value is list of labels in which this edge occures
binary representation of networks edges based on all possible edges in all networks</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shared(network_lists, labels, is_file = False):
    &#34;&#34;&#34;
    preprocessing function to sort edge list after weight

    Input
        
        
        network_list as returned by preprocess_edge_list
        labels is list of str containing names of each layer for later identification
        if is_file is True then network_lists is list of paths to pickled networks else contains python objects

    Output
        list of networks containing sorted edge list
        dict of shared edges between networks
            key is edge id as provided in m &amp; value is list of labels in which this edge occures
        binary representation of networks edges based on all possible edges in all networks
    &#34;&#34;&#34;

    

    shared_edges = node_edge_similarities.compute_shared_layers(network_lists, labels, mapping = None, weight=False, is_file=is_file)

    binary = node_edge_similarities.compute_binary_layer(shared_edges, layers=labels)

    return shared_edges, binary</code></pre>
</details>
</dd>
<dt id="graphAlgorithms.example_pipelines.get_edge_similarity.preprocess_edge_list"><code class="name flex">
<span>def <span class="ident">preprocess_edge_list</span></span>(<span>networks, is_file=False, location=None, names=None)</span>
</code></dt>
<dd>
<section class="desc"><p>function to map edges to ids for faster &amp; easier computation</p>
<p>Input
output of preprocess_graph
is_file if False then networks is list of networkx objects
if True then networks is list of file locations to python pickles
if True converted networks are saved as pickles to location
location str to where converted networks should be saved - will only be used if is_file is True</p>
<pre><code>names list of network names in same order as networks
</code></pre>
<p>Output
list of converted networks (or str to saved location)</p>
<pre><code>dict of edge to id mapping which can be used to reverse mapping
    in order to withdraw later information mapping needs to be kept
    key is str of node ids in format "node1, node2", which can be split into a list
        both edge directions are stored &amp; the same value is assigned to them
    value is id assigned to the particular edge
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess_edge_list(networks, is_file = False, location = None, names= None):
    &#34;&#34;&#34;
    function to map edges to ids for faster &amp; easier computation

    Input
        output of preprocess_graph
        is_file if False then networks is list of networkx objects
            if True then networks is list of file locations to python pickles
                if True converted networks are saved as pickles to location
        location str to where converted networks should be saved - will only be used if is_file is True

        names list of network names in same order as networks

    Output
        list of converted networks (or str to saved location)

        dict of edge to id mapping which can be used to reverse mapping
            in order to withdraw later information mapping needs to be kept
            key is str of node ids in format &#34;node1, node2&#34;, which can be split into a list
                both edge directions are stored &amp; the same value is assigned to them
            value is id assigned to the particular edge

    &#34;&#34;&#34;

    if not is_file:
        for i in range(len(networks)):
            if i == 0:
                m, n = node_edge_similarities.map_edge_to_id(networks[i], mapping={}, next_value=0)

            else:
                m, n = node_edge_similarities.map_edge_to_id(networks[i], mapping=m, next_value=n)

        network_lists = []
        for net in networks:
            network_lists.append(node_edge_similarities.construct_mapped_edge(m, net))

        return network_lists, m


    else:
        for i in range(len(networks)):
            #load file from disk
            
            with open(networks[i], &#34;rb&#34;) as f:
                net = pickle.load(f)

            if i % 10 == 0:
                print(&#34;loaded &#34;, i , &#34;network from disk out of &#34;, len(networks))


            if i == 0:
                m, n = node_edge_similarities.map_edge_to_id(net, mapping={}, next_value=0)

            else:
                m, n = node_edge_similarities.map_edge_to_id(net, mapping=m, next_value=n)


        network_lists = []
        for i in range(len(networks)):
            with open(networks[i], &#34;rb&#34;) as f:
                net = pickle.load(f)

            lst = list(dict.fromkeys(node_edge_similarities.construct_mapped_edge(m, net)))
            #save
            name = names[i]

            with open(location + name+&#34;.pckl&#34;, &#34;wb&#34;) as f:
                pickle.dump(lst, f, protocol=4)

            print(&#34;saved&#34;)
            network_lists.append(location + name+&#34;.pckl&#34;)

        return network_lists, m</code></pre>
</details>
</dd>
<dt id="graphAlgorithms.example_pipelines.get_edge_similarity.preprocess_graph"><code class="name flex">
<span>def <span class="ident">preprocess_graph</span></span>(<span>net_temp, attribute='weight', location=None, labels=None)</span>
</code></dt>
<dd>
<section class="desc"><p>function to convert list of networkx graph objects into list of sublist format as needed by
these functions</p>
<p>Input
net_temp list of networkx graph objects</p>
<pre><code>weight edge attribute to be converted

location is str of were output should be saved
    if None then a list of edgelists is returned else their pickled location is returned

labels is list of network names in same order as in net_temp
    only needed if location is not None
</code></pre>
<p>Output
list of graph objects in edge list format or if location is not None list of path location of saved objects</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess_graph(net_temp, attribute=&#34;weight&#34;, location = None, labels = None):
    &#34;&#34;&#34;
    function to convert list of networkx graph objects into list of sublist format as needed by
    these functions

    Input
        net_temp list of networkx graph objects

        weight edge attribute to be converted

        location is str of were output should be saved
            if None then a list of edgelists is returned else their pickled location is returned

        labels is list of network names in same order as in net_temp
            only needed if location is not None

    Output
        list of graph objects in edge list format or if location is not None list of path location of saved objects
    &#34;&#34;&#34;
    
    if location is None:
        networks = []
        for n in net_temp:
            temp = []
            edges = list(n.edges())
            for edge in edges:
                temp.append([edge[0], edge[1], n[edge[0]][edge[1]][attribute]])

            networks.append(temp)

        return networks

    else:
        networks = []
        for i in range(len(net_temp)):
            path = net_temp[i]
            name = labels[i]
            n=nx.read_weighted_edgelist(path)

            temp = []
            edges = list(n.edges())
            for edge in edges:
                temp.append([edge[0], edge[1], n[edge[0]][edge[1]][attribute]])

                        
            #save converted
            print(&#34;save&#34;, name)
            with open(location + name+&#34;.pckl&#34;, &#34;wb&#34;) as f:
                pickle.dump(temp, f, protocol=4)

            networks.append(location + name+&#34;.pckl&#34;)

        return networks</code></pre>
</details>
</dd>
<dt id="graphAlgorithms.example_pipelines.get_edge_similarity.sort_list"><code class="name flex">
<span>def <span class="ident">sort_list</span></span>(<span>networks, m, is_file=False, location=None)</span>
</code></dt>
<dd>
<section class="desc"><p>preprocessing function to sort edge list after weight</p>
<p>Input
output of preprocess_graph
mapping as returned by preprocess_edge_list</p>
<pre><code>if is_file is True then networks is list of paths to pickled networks else contains python objects
</code></pre>
<p>Output
list of networks containing sorted edge list or if_file then contains file location of pickled objects</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_list(networks, m,  is_file = False, location=None):
    &#34;&#34;&#34;
    preprocessing function to sort edge list after weight

    Input
        output of preprocess_graph
        mapping as returned by preprocess_edge_list
        
        if is_file is True then networks is list of paths to pickled networks else contains python objects

    Output
        list of networks containing sorted edge list or if_file then contains file location of pickled objects
        
    &#34;&#34;&#34;

    sorted_networks = []
    if not is_file:
        for net in networks:
            sorted_networks.append(node_edge_similarities.sort_edge_list(net, m))

    else:
        for path in networks:
            with open(path, &#34;rb&#34;) as f:
                net = pickle.load(f)
            name =  path.split(&#34;/&#34;)[-1].replace(&#34;.pckl&#34;, &#34;&#34;)
            temp = node_edge_similarities.sort_edge_list(net, m)

            with open(location + name+&#34;.pckl&#34;, &#34;wb&#34;) as f:
                pickle.dump(temp, f, protocol=4)

            sorted_networks.append(location + name+&#34;.pckl&#34;)

    

    return sorted_networks</code></pre>
</details>
</dd>
<dt id="graphAlgorithms.example_pipelines.get_edge_similarity.sort_list_and_get_shared"><code class="name flex">
<span>def <span class="ident">sort_list_and_get_shared</span></span>(<span>networks, m, network_lists, labels, is_file=False)</span>
</code></dt>
<dd>
<section class="desc"><p>preprocessing function to sort edge list after weight</p>
<p>Input
output of preprocess_graph
mapping as returned by preprocess_edge_list
network_list as returned by preprocess_edge_list
labels is list of str containing names of each layer for later identification
if is_file is True then networks is list of paths to pickled networks else contains python objects</p>
<p>Output
list of networks containing sorted edge list
dict of shared edges between networks
key is edge id as provided in m &amp; value is list of labels in which this edge occures
binary representation of networks edges based on all possible edges in all networks</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_list_and_get_shared(networks, m, network_lists, labels, is_file = False):
    &#34;&#34;&#34;
    preprocessing function to sort edge list after weight

    Input
        output of preprocess_graph
        mapping as returned by preprocess_edge_list
        network_list as returned by preprocess_edge_list
        labels is list of str containing names of each layer for later identification
        if is_file is True then networks is list of paths to pickled networks else contains python objects

    Output
        list of networks containing sorted edge list
        dict of shared edges between networks
            key is edge id as provided in m &amp; value is list of labels in which this edge occures
        binary representation of networks edges based on all possible edges in all networks
    &#34;&#34;&#34;

    sorted_networks = []
    if not is_file:
        for net in networks:
            sorted_networks.append(node_edge_similarities.sort_edge_list(net, m))

    else:
        for path in networks:
            with open(path, &#34;rb&#34;) as f:
                net = pickle.load(f)

            sorted_networks.append(node_edge_similarities.sort_edge_list(net, m))

    shared_edges = node_edge_similarities.compute_shared_layers(network_lists, labels, mapping = None, weight=False)

    binary = node_edge_similarities.compute_binary_layer(shared_edges, layers=labels)

    return sorted_networks, shared_edges, binary</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="graphAlgorithms.example_pipelines" href="index.html">graphAlgorithms.example_pipelines</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="graphAlgorithms.example_pipelines.get_edge_similarity.estimate_similarities_edges" href="#graphAlgorithms.example_pipelines.get_edge_similarity.estimate_similarities_edges">estimate_similarities_edges</a></code></li>
<li><code><a title="graphAlgorithms.example_pipelines.get_edge_similarity.get_shared" href="#graphAlgorithms.example_pipelines.get_edge_similarity.get_shared">get_shared</a></code></li>
<li><code><a title="graphAlgorithms.example_pipelines.get_edge_similarity.preprocess_edge_list" href="#graphAlgorithms.example_pipelines.get_edge_similarity.preprocess_edge_list">preprocess_edge_list</a></code></li>
<li><code><a title="graphAlgorithms.example_pipelines.get_edge_similarity.preprocess_graph" href="#graphAlgorithms.example_pipelines.get_edge_similarity.preprocess_graph">preprocess_graph</a></code></li>
<li><code><a title="graphAlgorithms.example_pipelines.get_edge_similarity.sort_list" href="#graphAlgorithms.example_pipelines.get_edge_similarity.sort_list">sort_list</a></code></li>
<li><code><a title="graphAlgorithms.example_pipelines.get_edge_similarity.sort_list_and_get_shared" href="#graphAlgorithms.example_pipelines.get_edge_similarity.sort_list_and_get_shared">sort_list_and_get_shared</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>